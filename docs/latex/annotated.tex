\doxysection{Class List}
Here are the classes, structs, unions and interfaces with brief descriptions\+:\begin{DoxyCompactList}
\item\contentsline{section}{\mbox{\hyperlink{struct_a}{A$<$ T $>$}} }{\pageref{struct_a}}{}
\item\contentsline{section}{\mbox{\hyperlink{struct_b}{B$<$ T $>$}} }{\pageref{struct_b}}{}
\item\contentsline{section}{\mbox{\hyperlink{struct_expression}{Expression}} }{\pageref{struct_expression}}{}
\item\contentsline{section}{\mbox{\hyperlink{struct_generator}{Generator$<$ T $>$}} \\*The class name \textquotesingle{}\mbox{\hyperlink{struct_generator}{Generator}}\textquotesingle{} is our choice and it is not required for coroutine magic. Compiler recognizes coroutine by the presence of \textquotesingle{}co\+\_\+yield\textquotesingle{} keyword. You can use name \textquotesingle{}\mbox{\hyperlink{struct_generator}{Generator}}\textquotesingle{} (or any other name) instead as long as you include nested struct \mbox{\hyperlink{struct_generator_1_1promise__type}{promise\+\_\+type}} with \textquotesingle{}\mbox{\hyperlink{struct_generator}{Generator}} get\+\_\+return\+\_\+object()\textquotesingle{} method. Note\+: You need to adjust class constructor/destructor names too when choosing to rename class }{\pageref{struct_generator}}{}
\item\contentsline{section}{\mbox{\hyperlink{classcontainers_1_1_hashtable}{containers\+::\+Hashtable$<$ Val $>$}} }{\pageref{classcontainers_1_1_hashtable}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_lexer}{Lexer}} }{\pageref{class_lexer}}{}
\item\contentsline{section}{\mbox{\hyperlink{struct_my_obj}{My\+Obj}} }{\pageref{struct_my_obj}}{}
\item\contentsline{section}{\mbox{\hyperlink{struct_node}{Node}} }{\pageref{struct_node}}{}
\item\contentsline{section}{\mbox{\hyperlink{struct_not_implemented_exception}{Not\+Implemented\+Exception}} }{\pageref{struct_not_implemented_exception}}{}
\item\contentsline{section}{\mbox{\hyperlink{structajc_1_1_parser}{ajc\+::\+Parser}} }{\pageref{structajc_1_1_parser}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_parser}{Parser}} }{\pageref{class_parser}}{}
\item\contentsline{section}{\mbox{\hyperlink{struct_generator_1_1promise__type}{Generator$<$ T $>$\+::promise\+\_\+type}} }{\pageref{struct_generator_1_1promise__type}}{}
\item\contentsline{section}{\mbox{\hyperlink{classreal__fs}{real\+\_\+fs}} \\*Real\+\_\+fs -\/ An implementation of vfs using the real underlying filesystem }{\pageref{classreal__fs}}{}
\item\contentsline{section}{\mbox{\hyperlink{struct_error_1_1_syntax__error}{Error\+::\+Syntax\+\_\+error}} }{\pageref{struct_error_1_1_syntax__error}}{}
\item\contentsline{section}{\mbox{\hyperlink{struct_benchmark_1_1test}{Benchmark\+::test}} }{\pageref{struct_benchmark_1_1test}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_token}{Token}} }{\pageref{class_token}}{}
\item\contentsline{section}{\mbox{\hyperlink{classvfs}{vfs}} \\*Base class for all virtual filesystem components }{\pageref{classvfs}}{}
\item\contentsline{section}{\mbox{\hyperlink{struct_error_1_1_zero__divide}{Error\+::\+Zero\+\_\+divide}} }{\pageref{struct_error_1_1_zero__divide}}{}
\end{DoxyCompactList}
